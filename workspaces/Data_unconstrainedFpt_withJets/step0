#!/usr/bin/env python
#
# Prepare the inputs for HistFactory
#
# Carlos.Solans@cern.ch,  January 2014
# davide.gerbaudo@gmail.com, rewrite May 2015

import ROOT
ROOT.gROOT.SetBatch(True)
from collections import defaultdict
import datetime
import os
import pprint
import sys
#import AtlasStyle
import array

"""
Prepare a dataset based on the inputs from Suneet (TH2D l1pt vs Mcoll).
"""


def average_histogram(h1, h2, target_name='average_histo'):
    "Clone the first histograms and fill it with the bin-by-bin average of h1 and h2"
    h_out = h1.Clone(target_name)
    h_out.Add(h2)
    h_out.Scale(0.5)
    return h_out

def rebinned_histoname(sample='', variation='', em_me=''):
    "note that the naming here is slightly different; but use the same key"
    templ_h_name = 'h_SR_%s_Rebinned_mcollCorr_x_pt1_%s'
    hname = templ_h_name%('EM' if em_me=='emu' else
                          'ME' if em_me=='mue' else 'unknown',
                          sample+('' if variation=='NOM' else ('_'+variation)))  # todo: use _NOM also
    return hname

def fill_pt_slice_histo(h_m_vs_pt, h_m, pt_min, pt_max):
    "project 2D histo m_vs_pt on 1D m slicing a pt interval [pt_min, pt_max["
    xaxis = h_m_vs_pt.GetXaxis()
    yaxis = h_m_vs_pt.GetYaxis()
    nbinsx = xaxis.GetNbins()
    nbinsy = yaxis.GetNbins()
    origin_pt_bins = array.array('f', [xaxis.GetBinLowEdge(j+1) for j in range(nbinsx+1)])
    origin_m_bins  = array.array('f', [yaxis.GetBinLowEdge(k+1) for k in range(nbinsy+1)])
    n_m_bins = len(origin_m_bins)-1
    m_binning = (n_m_bins, origin_m_bins)
    dummy_histo = ROOT.TH1F("dummy", '', *m_binning)
    for pt in origin_pt_bins:
	if pt_min <= pt < pt_max:
	    for mass in origin_m_bins:
                dest_bin = dummy_histo.FindBin(mass)
                orig_bin = h_m_vs_pt.FindBin(pt, mass)
                dummy_histo.SetBinContent(dest_bin, h_m_vs_pt.GetBinContent(orig_bin))
                dummy_histo.SetBinError  (dest_bin, h_m_vs_pt.GetBinError  (orig_bin))
            h_m.Add(dummy_histo)

def pt_slice_histoname(sample='', variation='', em_me='', l1pt_key='', jet=''):
    "note again a slightly different convention; still use the same standard keys"
    templ_h_name = 'Mcoll_{sample}{variation}_{emme}_{l1pt}{jet}'
    sample = ('data' if sample=='data' else
              'Fakes' if sample=='fake' else
              'signal' if sample=='signaltaue' else
              'wrong_signal' if sample=='signaltaumu' else 'unknown')
    emme = ('EM' if em_me=='emu' else
            'ME' if em_me=='mue' else 'unknown')
    variation = ('' if variation=='NOM' else ('_'+variation)) # todo: use _NOM also
    return templ_h_name.format(**{'sample':sample, 'variation':variation, 'emme': emme, 'l1pt': l1pt_key, 'jet':jet})

def shift_nonpositive_bins(h, value=0.001, error=0.00001):
    """
    For all bins with content <=0, force their content to value, error
    """
    bins = range(1, 1+h.GetXaxis().GetNbins())
    for b in bins:
        if h.GetBinContent(b)<=0.0:
            h.SetBinContent(b, value)
            h.SetBinError  (b, error)
    # # DG-2015-05-19 : is this obsolete or needed? ask Avital
    # if hwrsg2.GetBinContent(b+1)<0: # why a different treatment for hwrsg2 ?
    #     print "NEGATIVE VALUES in wrong signal sample!"

def transform_to_0_n_bins(h_orig):
    "transform histo binning from [m_min, m_max] to [0, n]"
    name = h_orig.GetName()+'_rebin'
    title = h_orig.GetTitle()
    nthrow = 0
    n_m_bins_pruned = len(origin_m_bins)-nthrow
    h_dest = ROOT.TH1F(name, title, n_m_bins_pruned, 0, n_m_bins_pruned)
    for b in range(n_m_bins_pruned):
        bin_orig = b+1+nthrow
        bin_dest = b+1
        if h_orig.GetBinContent(bin_orig)>0:
            h_dest.SetBinContent(bin_dest, h_orig.GetBinContent(bin_orig))
            h_dest.SetBinError (bin_dest, h_orig.GetBinError   (bin_orig))
        else:
            h_dest.SetBinContent(bin_dest, 0.001)
            h_dest.SetBinError (bin_dest, 0.00001)
    return h_dest

### INPUT DIR ##################

input_dir = "/scratch/gerbaudo/hlfv_fit_tests/take1/FitModel/Apr_26_histos/"
output_dir = "data/"

### SIGNAL STRENGTH ###########
strength = 0.0
#############################
data_variations = ['NOM']
fake_variations = ['NOM',
                   'EL_RE_UP', 'EL_RE_DOWN', 'EL_FR_UP', 'EL_FR_DOWN',
                   'MU_RE_UP', 'MU_RE_DOWN', 'MU_FR_UP', 'MU_FR_DOWN']
sign_variations = ['NOM']
### OUTPUT FILE ##############
fw1 = ROOT.TFile(output_dir+"/simple.root","RECREATE")
jet_variations = ['', '_jets']

class Variation(object):
    """
    Hold up/down normalization in fake variations
    """
    def __init__(self, emu_mue='', sysname='', jetvariation='', l1pt='', updown=(1.0, 1.0)):
        self.emme = emu_mue
        self.sys = sysname
        self.jet = jetvariation
        self.l1pt = l1pt
        self.up = updown[0]
        self.do = updown[1]
    def as_dict(self, precision=6):
        "stringified dictionary, so that we can set the precision"
        def as_string(f, precision=precision):
            precision = str(precision)
            return ("{0:."+precision+"f}").format(f)
        return {'UPvalue': self.up, 'DNvalue': self.do}
        # return "{'UPvalue': %s, 'DNvalue': %s}" % (as_string(self.up), as_string(self.do))

class FakeSystematicRegister(object):
    """
    Holder for the normalization scales of the fake systematics.
    Store the values and print them out to a file that is then fed to
    step1.
    """
    def __init__(self):
        self._variations = []
    def add(self, emu_mue='', sysname='', jetvariation='', l1pt='', updown=(1.0, 1.0)):
        self._variations.append(Variation(emu_mue, sysname, jetvariation, l1pt, updown))
    def as_dict(self):
        "example keys : [emu_MU_FR][_jets][l1pt0][UPvalue]"
        emu_mue        =  sorted(list(set(v.emme for v in self._variations)))
        systematics    = sorted(list(set(v.sys for v in self._variations)))
        jet_variations = sorted(list(set(v.jet for v in self._variations)))
        l1pts          = sorted(list(set(v.l1pt for v in self._variations)))
        # I could use a nested defaultdict, but then pprint doesn't work nicely
        out_dict = dict([(emme+'_'+sys,
                          dict([(j,
                                 dict([(l1pt, {})
                                       for l1pt in l1pts]))
                                for j in jet_variations]))
                          for emme in emu_mue for sys in systematics])
        for var in self._variations:
            out_dict[var.emme+'_'+var.sys][var.jet][var.l1pt] = var.as_dict()
        return out_dict

fake_systematics = FakeSystematicRegister()

for jet in jet_variations:
        ### FINAL BINNING ############
        target_pt1_bins = array.array('f',(12,15,20,25,30,35,1000))
        target_m_bins = (array.array('f', [0] + range(60, 250, 5) + [250,260,270,280,290,300,320,350,400,450]) if jet=='' else
                         array.array('f', (0,60,80,100,120,130,140,150,160,180,200,230,260,300,350,400,450)))
	#### Get Files and histograms ####
        files = {}
        histos = {}
        for sample, variations in [('data', data_variations),
                                   ('fake', fake_variations),
                                   ('signaltaue', sign_variations),
                                   ('signaltaumu', sign_variations)]:
                for variation in variations:
                        for em_me in ['emu', 'mue']:
                                key = sample+'_'+variation+'_sr_'+em_me+'_os'+jet
                                filename = input_dir+'/'+key+'.root'
                                files[key] = ROOT.TFile(filename)
                                histoname = 'h_mcoll_vs_pt1_'+sample+'_'+variation+'_sr_'+em_me+'_os'+jet
                                clonename = ""
                                histo = files[key].Get(histoname)
                                if not histo:
                                    print "missing %s from %s"%(histoname, filename)
                                else:
                                    histos[key] = histo

        fw1.cd()
	## Rebin 2D histos ###

	print "Rebinning {0}...".format(jet)

        n_target_pt1_bins = len(target_pt1_bins)-1
        n_target_m_bins = len(target_m_bins)-1

        title = "l_1 p^{T};Mcoll (GeV)"
        binning = (n_target_pt1_bins, target_pt1_bins, n_target_m_bins, target_m_bins)
        rebinned_histos = {}
        for sample, variations, em_mes in [('data', data_variations, ('emu', 'mue')),
                                           ('fake', fake_variations, ('emu', 'mue')),
                                           ('signaltaumu', ('NOM',),    ('mue',)),
                                           ('signaltaue',  ('NOM',),    ('mue',))]:
            for variation in variations:
                for em_me in em_mes:
                    key = sample+'_'+variation+'_sr_'+em_me+'_os'+jet
                    h_rebin_name = rebinned_histoname(sample, variation, em_me)
                    rebinned_histos[key] = ROOT.TH2F(h_rebin_name, title, *binning)
                    h_orig =          histos[key]
                    h_rebn = rebinned_histos[key]
                    xaxis = h_orig.GetXaxis()
                    yaxis = h_orig.GetYaxis()

                    for ix in range(1, 1+xaxis.GetNbins()):
                        for iy in range(1, 1+yaxis.GetNbins()):
                            x = xaxis.GetBinCenter(ix)
                            y = yaxis.GetBinCenter(iy)
                            h_rebn.Fill(x, y, h_orig.GetBinContent(ix, iy))
                    # for x in range(xaxis.GetNbins()):
                    #     for y in range(yaxis.GetNbins()):
                    #         i=x+1
                    #         j=y+1
                    #         ix = xaxis.GetBinCenter(i)
                    #         jy = yaxis.GetBinCenter(j)
                    #         h_rebn.Fill(ix, jy, h_orig.GetBinContent(i, j))
                    #         print "fill (%d, %d) -> (%d, %d)"%(i, j, ix, jy)
                    def format_h2_summary(h):
                        return "{0}[{1}][{2}] ({3:.4f})".format(h.GetName(), h.GetNbinsX(), h.GetNbinsY(), h.Integral())
                    print "rebin {0} to {1}".format(format_h2_summary(h_orig), format_h2_summary(h_rebn))
                    if sample=='data':
                        c = ROOT.TCanvas(key, '')
                        c.Divide(2,1)
                        c.cd(1)
                        h_orig.Draw('col3z text')
                        ROOT.gPad.SetLogx()
                        c.cd(2)
                        h_rebn.Draw('col3z text')
                        ROOT.gPad.SetLogx()
                        c.Update()
                        c.SaveAs(c.GetName()+'.png')
	## Rebin uniformly to indices
        template_histo = rebinned_histos['data_NOM_sr_mue_os'+jet]
        xaxis = template_histo.GetXaxis()
        yaxis = template_histo.GetYaxis()
	nbinsx = xaxis.GetNbins()
	nbinsy = yaxis.GetNbins()
	origin_pt_bins = array.array('f', [xaxis.GetBinLowEdge(j+1) for j in range(nbinsx+1)])
	origin_m_bins  = array.array('f', [yaxis.GetBinLowEdge(k+1) for k in range(nbinsy+1)])
	n_m_bins = len(origin_m_bins)-1
        title = ";Mcoll (GeV)"
        m_binning = (n_m_bins, origin_m_bins)
        sliced_histos = {}
        sliced_rebinned_histos = {}
	for i in range(len(target_pt1_bins)-1):
            pt_min = target_pt1_bins[i]
            pt_max = target_pt1_bins[i+1]
            l1pt_key = "l1pt{0:d}".format(i)
            sliced_histos_this_pt = {}
            sliced_rebinned_histos_this_pt = {}
            for sample, variations, em_mes in [('data', data_variations, ('emu', 'mue')),
                                               ('fake', fake_variations, ('emu', 'mue')),
                                               ('signaltaumu', ('NOM',),    ('mue',)),
                                               ('signaltaue',  ('NOM',),    ('mue',))]:
                for variation in variations:
                    for em_me in em_mes:
                        key = sample+'_'+variation+'_sr_'+em_me+'_os'+jet
                        h_m_vs_pt = rebinned_histos[key]
                        h_m_name = pt_slice_histoname(sample=sample, variation=variation, em_me=em_me, l1pt_key=l1pt_key, jet=jet)
                        h_m =  ROOT.TH1F(h_m_name, title, *m_binning)
                        fill_pt_slice_histo(h_m_vs_pt, h_m, pt_min, pt_max)
                        sliced_histos_this_pt[key] = h_m
                        # shift_nonpositive_bins(h_m) # we might want to do this after adding the signal?

            # throw away first bins
            # DG what he means is: map to a binning 0.N
            for sample, variations, em_mes in [('data', data_variations, ('emu', 'mue')),
                                               ('fake', fake_variations, ('emu', 'mue')),
                                               ('signaltaumu', ('NOM',),    ('mue',)),
                                               ('signaltaue',  ('NOM',),    ('mue',))]:
                for variation in variations:
                    for em_me in em_mes:
                        key = sample+'_'+variation+'_sr_'+em_me+'_os'+jet
                        h_rebin = transform_to_0_n_bins(sliced_histos_this_pt[key])
                        h_rebin.Write()
                        sliced_rebinned_histos_this_pt[key] = h_rebin
            sliced_rebinned_histos[l1pt_key] = sliced_rebinned_histos_this_pt

            hme1   = sliced_rebinned_histos_this_pt['data_NOM_sr_mue_os'+jet]
            hem1   = sliced_rebinned_histos_this_pt['data_NOM_sr_emu_os'+jet]
            hsg1   = sliced_rebinned_histos_this_pt['signaltaumu_NOM_sr_mue_os'+jet]
            hwrsg1 = sliced_rebinned_histos_this_pt['signaltaue_NOM_sr_mue_os'+jet]
            ### ADD SIGNAL TO SUM MC ### DG I think this is wrong; these are not the tot mc, but data
            hme1.Add(hsg1,strength)
            hem1.Add(hwrsg1,strength)
            h_BaseBkg = average_histogram(hme1, hem1, "Base_Bkg_{0}{1}".format(l1pt_key, jet))
            hme1.Write()
            hem1.Write()
            hsg1.Write()
            hwrsg1.Write()
            h_BaseBkg.Write()

	# Get scaling for fake systematics
	for i in range(len(target_pt1_bins)-1):
            l1pt_key = "l1pt{0:d}".format(i)
            histos =  sliced_rebinned_histos[l1pt_key]
            for em_me in ['emu', 'mue']:
                h_nom = histos['fake_NOM_sr_mue_os'+jet]
                norm_nom = h_nom.Integral()
                for sys in ['EL_RE', 'EL_FR', 'MU_RE', 'MU_FR']:
                    h_up = histos['fake_'+sys+'_UP_sr_'+em_me+'_os'+jet]
                    h_do = histos['fake_'+sys+'_DOWN_sr_'+em_me+'_os'+jet]
                    norm_do = h_do.Integral()/norm_nom
                    norm_up = h_up.Integral()/norm_nom
                    fake_systematics.add(emu_mue=em_me, sysname=sys, jetvariation=jet, l1pt=l1pt_key, updown=(norm_up, norm_do))
                    h_do.Scale(1.0/norm_do)
                    h_up.Scale(1.0/norm_up)
                    h_do.Write() #overwrite with normalized histo?
                    h_up.Write()

fw1.Close()

with open(output_dir+'/fake_systematics.py', 'w') as out_sys_file:
    out_sys_file.write(("# fake systematics evaluated on {0}\n".format(datetime.date.today().isoformat())
                       +pprint.pformat(fake_systematics.as_dict())
                       +'\n'))
