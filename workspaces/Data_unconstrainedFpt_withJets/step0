#!/usr/bin/env python
#
# Prepare the inputs for HistFactory
#
# Carlos.Solans@cern.ch,  January 2014
# davide.gerbaudo@gmail.com, rewrite May 2015

import ROOT
ROOT.gROOT.SetBatch(True)
import argparse
from collections import defaultdict
import datetime
import os
import pprint
import sys
#import AtlasStyle
import array

program_description="""
Prepare a dataset based on the inputs from Suneet (TH2D l1pt vs Mcoll)

Example:
> %(prog)s ./Apr_26_histos/ ./data/ --verbose
"""
def main():
    parser = argparse.ArgumentParser(description=program_description, usage='%(prog)s input output [options]')
    parser.add_argument('input_dir', help='directory containing the 2D histograms')
    parser.add_argument('output_dir', help='directory where the output will be stored')
    parser.add_argument('-p', '--plot', action='store_true', help='plot rebinned histograms')
    parser.add_argument('-s', '--strength', default=0.0, help='strength of the injected signal (used for spurious test)')
    parser.add_argument('-v', '--verbose', action='store_true', help='increase output verbosity')
    parser.add_argument('-n', '--negative', action='store_true', help='allow negative bin contents')
    parser.add_argument('--fake-sys', default='fake_systematics.py', help='where the normalization of the fake sys will be saved')
    args = parser.parse_args()
    input_dir = args.input_dir
    output_dir = mkdir_if_needed(args.output_dir)
    verbose = args.verbose
    signal_strength = args.strength
    jet_variations = ['', '_jets']
    data_variations = ['NOM']
    fake_variations = ['NOM',
                       'EL_RE_UP', 'EL_RE_DOWN', 'EL_FR_UP', 'EL_FR_DOWN',
                       'MU_RE_UP', 'MU_RE_DOWN', 'MU_FR_UP', 'MU_FR_DOWN']
    sign_variations = ['NOM']
    samples_with_variations = [('data', data_variations, ('emu', 'mue')),
                               ('fake', fake_variations, ('emu', 'mue')),
                               ('signaltaumu', ('NOM',),    ('mue',)), # signal only goes in mue
                               ('signaltaue',  ('NOM',),    ('mue',))]
    output_file = ROOT.TFile(output_dir+"/simple.root","RECREATE")
    fake_systematics = FakeSystematicRegister()

    for jet in jet_variations:
        # Target binning
        # DG todo : add check that target_bin < orig_bin
        target_pt1_bins = array.array('f',(12,15,20,25,30,35,1000))
        target_m_bins = (array.array('f', [0] + range(60, 250,  5) + range(250, 300, 10) + [300,320,350,400,450]) if jet=='' else
                         array.array('f', [0] + range(60, 120, 20) + range(120, 160, 10) + [160,180,200,230,260,300,350,400,450]))

        files, histos = collect_inputs(input_dir, samples_with_variations, jet)

        # Rebin 2D histos ###
        if verbose: print "Rebinning {0}...".format(jet)
        n_target_pt1_bins = len(target_pt1_bins)-1
        n_target_m_bins = len(target_m_bins)-1

        title = "l_1 p^{T};Mcoll (GeV)"
        binning = (n_target_pt1_bins, target_pt1_bins, n_target_m_bins, target_m_bins)
        rebinned_histos = {}
        for sample, variations, em_mes in [('data', data_variations, ('emu', 'mue')),
                                           ('fake', fake_variations, ('emu', 'mue')),
                                           ('signaltaumu', ('NOM',),    ('mue',)), # signal only goes in mue
                                           ('signaltaue',  ('NOM',),    ('mue',))]:
            for variation in variations:
                for em_me in em_mes:
                    key = sample+'_'+variation+'_sr_'+em_me+'_os'+jet
                    h_rebin_name = rebinned_histoname(sample, variation, em_me)
                    rebinned_histos[key] = ROOT.TH2F(h_rebin_name, title, *binning)
                    h_orig =          histos[key]
                    h_rebn = rebinned_histos[key]
                    xaxis = h_orig.GetXaxis()
                    yaxis = h_orig.GetYaxis()
                    # DG todo propagate error
                    for ix in range(1, 1+xaxis.GetNbins()):
                        for iy in range(1, 1+yaxis.GetNbins()):
                            x = xaxis.GetBinCenter(ix)
                            y = yaxis.GetBinCenter(iy)
                            h_rebn.Fill(x, y, h_orig.GetBinContent(ix, iy))
                    def format_h2_summary(h):
                        return "{0}[{1}][{2}] ({3:.4f})".format(h.GetName(), h.GetNbinsX(), h.GetNbinsY(), h.Integral())
                    if verbose: print "rebin {0} to {1}".format(format_h2_summary(h_orig), format_h2_summary(h_rebn))
                    if args.plot and sample=='data':
                        plot_2d_before_after(h_orig, h_rebn, output_dir+'/'+key)
	## Rebin uniformly to indices
        template_histo = rebinned_histos['data_NOM_sr_mue_os'+jet]
        xaxis = template_histo.GetXaxis()
        yaxis = template_histo.GetYaxis()
	nbinsx = xaxis.GetNbins()
	nbinsy = yaxis.GetNbins()
	origin_pt_bins = array.array('f', [xaxis.GetBinLowEdge(j+1) for j in range(nbinsx+1)])
	origin_m_bins  = array.array('f', [yaxis.GetBinLowEdge(k+1) for k in range(nbinsy+1)])
	n_m_bins = len(origin_m_bins)-1
        title = ";Mcoll (GeV)"
        m_binning = (n_m_bins, origin_m_bins)
        sliced_histos = {}
	for i in range(len(target_pt1_bins)-1):
            pt_min = target_pt1_bins[i]
            pt_max = target_pt1_bins[i+1]
            l1pt_key = "l1pt{0:d}".format(i)
            sliced_histos_this_pt = {}
            for sample, variations, em_mes in [('data', data_variations, ('emu', 'mue')),
                                               ('fake', fake_variations, ('emu', 'mue')),
                                               ('signaltaumu', ('NOM',),    ('mue',)),
                                               ('signaltaue',  ('NOM',),    ('mue',))]:
                for variation in variations:
                    for em_me in em_mes:
                        key = sample+'_'+variation+'_sr_'+em_me+'_os'+jet
                        h_m_vs_pt = rebinned_histos[key]
                        h_m_name = pt_slice_histoname(sample=sample, variation=variation, em_me=em_me, pt_bin=i, jet=jet)
                        h_m =  ROOT.TH1F(h_m_name, title, *m_binning)
                        fill_pt_slice_histo(h_m_vs_pt, h_m, pt_min, pt_max)
                        sliced_histos_this_pt[key] = h_m
                        shift_nonpositive_bins(h_m) # we might want to do this after adding the signal?
            sliced_histos[l1pt_key] = sliced_histos_this_pt
            hme1   = sliced_histos_this_pt['data_NOM_sr_mue_os'+jet]
            hem1   = sliced_histos_this_pt['data_NOM_sr_emu_os'+jet]
            hsg1   = sliced_histos_this_pt['signaltaumu_NOM_sr_mue_os'+jet]
            hwrsg1 = sliced_histos_this_pt['signaltaue_NOM_sr_mue_os'+jet]
            ### ADD SIGNAL TO SUM MC ### DG I think this is wrong; these are not the tot mc, but data
            hme1.Add(hsg1,signal_strength)
            hem1.Add(hwrsg1,signal_strength)

            output_file.cd()
            hme1.Write()
            hem1.Write()
            hsg1.Write()
            hwrsg1.Write()
	# Get scaling for fake systematics
	for i in range(len(target_pt1_bins)-1):
            l1pt_key = "l1pt{0:d}".format(i)
            histos =  sliced_histos[l1pt_key]
            for em_me in ['emu', 'mue']:
                h_nom = histos['fake_NOM_sr_mue_os'+jet]
                norm_nom = h_nom.Integral()
                for sys in ['EL_RE', 'EL_FR', 'MU_RE', 'MU_FR']:
                    h_up = histos['fake_'+sys+'_UP_sr_'+em_me+'_os'+jet]
                    h_do = histos['fake_'+sys+'_DOWN_sr_'+em_me+'_os'+jet]
                    norm_do = h_do.Integral()/norm_nom
                    norm_up = h_up.Integral()/norm_nom
                    fake_systematics.add(emu_mue=em_me, sysname=sys, jetvariation=jet, l1pt=l1pt_key, updown=(norm_up, norm_do))
                    h_do.Scale(1.0/norm_do)
                    h_up.Scale(1.0/norm_up)

    output_file.Close()
    if verbose: print "saving fake systematic normalizations to {0}".format(args.fake_sys)
    with open(output_dir+'/'+args.fake_sys, 'w') as out_sys_file:
        out_sys_file.write(("# fake systematics evaluated on {0}\n".format(datetime.date.today().isoformat())
                           +pprint.pformat(fake_systematics.as_dict())
                           +'\n'))
#___________________________________________________________

def mkdir_if_needed(dirname) :
    dest_dir = None
    if os.path.exists(dirname) and os.path.isdir(dirname) :
        dest_dir = dirname
    elif not os.path.exists(dirname) :
        os.makedirs(dirname)
        dest_dir = dirname
    if not dest_dir:
        raise IOError("cannot create ouput dir %s"%dirname)
    return dest_dir

def collect_inputs(input_dir, samples_with_variations, jet):
    files = {}
    histos = {}
    for sample, variations, emu_mues in samples_with_variations:
        for variation in variations:
            for em_me in emu_mues:
                key = sample+'_'+variation+'_sr_'+em_me+'_os'+jet
                filename = input_dir+'/'+key+'.root'
                files[key] = ROOT.TFile(filename)
                histoname = 'h_mcoll_vs_pt1_'+sample+'_'+variation+'_sr_'+em_me+'_os'+jet
                clonename = ""
                histo = files[key].Get(histoname)
                if not histo:
                    raise IOError("missing %s from %s"%(histoname, filename))
                else:
                    histos[key] = histo
    return files, histos

def plot_2d_before_after(h_before, h_after, output_file):
    "plot the 2d histo before/after rebinning side-by-side"
    c = ROOT.TCanvas(output_file, '')
    c.Divide(2,1)
    c.cd(1)
    h_before.Draw('col3z text')
    ROOT.gPad.SetLogx()
    c.cd(2)
    h_after.Draw('col3z text')
    ROOT.gPad.SetLogx()
    c.Update()
    c.SaveAs(output_file+'.png')

def average_histogram(h1, h2, target_name='average_histo'):
    "Clone the first histograms and fill it with the bin-by-bin average of h1 and h2"
    h_out = h1.Clone(target_name)
    h_out.Add(h2)
    h_out.Scale(0.5)
    return h_out

def rebinned_histoname(sample='', variation='', em_me=''):
    "note that the naming here is slightly different; but use the same key"
    templ_h_name = 'h_SR_%s_Rebinned_mcollCorr_x_pt1_%s'
    hname = templ_h_name%('EM' if em_me=='emu' else
                          'ME' if em_me=='mue' else 'unknown',
                          sample+('' if variation=='NOM' else ('_'+variation)))  # todo: use _NOM also
    return hname

def fill_pt_slice_histo(h_m_vs_pt, h_m, pt_min, pt_max):
    "project 2D histo m_vs_pt on 1D m slicing a pt interval [pt_min, pt_max["
    xaxis = h_m_vs_pt.GetXaxis()
    yaxis = h_m_vs_pt.GetYaxis()
    nbinsx = xaxis.GetNbins()
    nbinsy = yaxis.GetNbins()
    origin_pt_bins = array.array('f', [xaxis.GetBinLowEdge(j+1) for j in range(nbinsx+1)])
    origin_m_bins  = array.array('f', [yaxis.GetBinLowEdge(k+1) for k in range(nbinsy+1)])
    n_m_bins = len(origin_m_bins)-1
    m_binning = (n_m_bins, origin_m_bins)
    dummy_histo = ROOT.TH1F("dummy", '', *m_binning)
    for pt in origin_pt_bins:
	if pt_min <= pt < pt_max:
	    for mass in origin_m_bins:
                dest_bin = dummy_histo.FindBin(mass)
                orig_bin = h_m_vs_pt.FindBin(pt, mass)
                dummy_histo.SetBinContent(dest_bin, h_m_vs_pt.GetBinContent(orig_bin))
                dummy_histo.SetBinError  (dest_bin, h_m_vs_pt.GetBinError  (orig_bin))
            h_m.Add(dummy_histo)

def pt_slice_histoname(sample='', variation='', em_me='', pt_bin=0, jet=''):
    "note again a slightly different convention; still use the same standard keys"
    templ_h_name = 'Mcoll_{sample}_{emme}{variation}_{l1pt}{jet}'
    sample = ('data' if sample=='data' else
              'Fakes' if sample=='fake' else
              'signal' if sample=='signaltaue' else
              'wrong_signal' if sample=='signaltaumu' else 'unknown')
    emme = ('EM' if em_me=='emu' else
            'ME' if em_me=='mue' else 'unknown')
    variation = ('' if variation=='NOM' else ('_'+variation)) # todo: use _NOM also
    return templ_h_name.format(**{'sample':sample, 'variation':variation, 'emme': emme, 'l1pt': pt_bin, 'jet':jet})

def shift_nonpositive_bins(h, value=0.001, error=0.00001):
    """
    For all bins with content <=0, force their content to value, error
    """
    bins = range(1, 1+h.GetXaxis().GetNbins())
    for b in bins:
        if h.GetBinContent(b)<=0.0:
            h.SetBinContent(b, value)
            h.SetBinError  (b, error)
    # # DG-2015-05-19 : is this obsolete or needed? ask Avital
    # if hwrsg2.GetBinContent(b+1)<0: # why a different treatment for hwrsg2 ?
    #     print "NEGATIVE VALUES in wrong signal sample!"

class Variation(object):
    """
    Hold up/down normalization in fake variations
    """
    def __init__(self, emu_mue='', sysname='', jetvariation='', l1pt='', updown=(1.0, 1.0)):
        self.emme = emu_mue
        self.sys = sysname
        self.jet = jetvariation
        self.l1pt = l1pt
        self.up = updown[0]
        self.do = updown[1]
    def as_dict(self, precision=6):
        "stringified dictionary, so that we can set the precision"
        def as_string(f, precision=precision):
            precision = str(precision)
            return ("{0:."+precision+"f}").format(f)
        return {'UPvalue': self.up, 'DNvalue': self.do}
        # return "{'UPvalue': %s, 'DNvalue': %s}" % (as_string(self.up), as_string(self.do))

class FakeSystematicRegister(object):
    """
    Holder for the normalization scales of the fake systematics.
    Store the values and print them out to a file that is then fed to
    step1.
    """
    def __init__(self):
        self._variations = []
    def add(self, emu_mue='', sysname='', jetvariation='', l1pt='', updown=(1.0, 1.0)):
        self._variations.append(Variation(emu_mue, sysname, jetvariation, l1pt, updown))
    def as_dict(self):
        "example keys : [emu_MU_FR][_jets][l1pt0][UPvalue]"
        emu_mue        =  sorted(list(set(v.emme for v in self._variations)))
        systematics    = sorted(list(set(v.sys for v in self._variations)))
        jet_variations = sorted(list(set(v.jet for v in self._variations)))
        l1pts          = sorted(list(set(v.l1pt for v in self._variations)))
        # I could use a nested defaultdict, but then pprint doesn't work nicely
        out_dict = dict([(emme+'_'+sys,
                          dict([(j,
                                 dict([(l1pt, {})
                                       for l1pt in l1pts]))
                                for j in jet_variations]))
                          for emme in emu_mue for sys in systematics])
        for var in self._variations:
            out_dict[var.emme+'_'+var.sys][var.jet][var.l1pt] = var.as_dict()
        return out_dict

if __name__=='__main__':
    main()
